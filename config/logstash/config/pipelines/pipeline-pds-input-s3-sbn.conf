input {
  # SBN
  s3 {
    bucket => "$S3_BUCKET_NAME"
    region => "us-west-2"
    prefix => "sbn/sbn-apache-http/"
    add_field => {
      "[organization][name]" => "sbn"
      "[url][domain]" => "pds-smallbodies.astro.umd.edu"
      "[url][scheme]" => "https"
      "[event][dataset]" => "sbn.http"
    }
    ecs_compatibility => v8
    id => "file_input_sbnumd1"
  }

  s3 {
    bucket => "$S3_BUCKET_NAME"
    region => "us-west-2"
    prefix => "sbn/sbn-psi-tomcat/"
    add_field => {
      "[organization][name]" => "sbn"
      "[url][domain]" => "sbn.psi.edu"
      "[url][scheme]" => "https"
      "[event][dataset]" => "sbn.http"
    }
    ecs_compatibility => v8
    id => "file_input_sbnpsi1"
  }

  s3 {
    bucket => "$S3_BUCKET_NAME"
    region => "us-west-2"
    prefix => "sbn/sbn-psi-tools/"
    add_field => {
      "[organization][name]" => "sbn"
      "[url][domain]" => "sbnapps.psi.edu"
      "[url][scheme]" => "https"
      "[event][dataset]" => "sbn.http"
    }
    ecs_compatibility => v8
    id => "file_input_sbnpsi2"
  }

}filter {

  # Currently, @timestamp is set to the current time.  We store that in the
  # index_time field so that we can tell when records are ingested.  Later,
  # @timestamp will be overwritten with the timestamp of the logged request.
  mutate {
    add_field => { "[event][ingested]" => "%{@timestamp}" }
  }

  # Add source file as useful metadata for logging purposes
  if [@metadata][s3][key] {
    mutate {
      add_field => {
        "[object][key]" => "%{[@metadata][s3][key]}"
        "[file][path]" => "s3://pds-dev-web-analytics/%{[@metadata][s3][key]}"
        "[file][name]" => "%{[@metadata][s3][key]}"
      }
    }
  }

  # Handle bad unicode characters
  mutate {
    replace => { "message" => "%{message}" }
    id => "fix_bad_unicode"
  }

  # Common fields for all logs
  mutate {
    add_field => {
      "[@metadata][timestamp]" => "%{+YYYY-MM-dd'T'HH:mm:ss.SSSZ}"
      "[event][kind]" => "event"
      "[event][category]" => ["web", "network"]
      "[event][type]" => ["access", "info"]
      "[event][dataset]" => "web.analytics"
      "[event][module]" => "web"
      "[event][provider]" => "pds"
      "[event][action]" => "access"
      "[event][sequence]" => "0"
    }
  }

  # Extract source address from message first
  if "%{[source][address]}" in [source][address] {
    grok {
      match => {
        "message" => [
          "%{IPORHOST:[source][address]}",
          "%{HOSTNAME:[source][address]}"
        ]
      }
      tag_on_failure => ["_source_address_parse_failure"]
    }
  }

  # Extract the message from the log
  grok {
    ecs_compatibility => "v8"
    match => { "message" => [
        # Apache Combined Log Format
        "%{COMBINEDAPACHELOG}",

        # Apache Common Log Format
        "%{COMMONAPACHELOG}",

        # IIS HTTP Log Format (with W3SVC)
        "%{TIMESTAMP_ISO8601:[event][start]} %{NOTSPACE:[server][site]} %{IP:[server][ip]} %{WORD:[http][request][method]} %{DATA:[url][path]}(?:%{URIPARAM:[url][query]})? %{NOTSPACE:[server][port]} %{NOTSPACE:[user][name]} %{IP:[source][address]} %{DATA:[user_agent][original]} %{NUMBER:[http][response][status_code]} %{NUMBER:[http][response][substatus]} %{NUMBER:[http][response][win32_status]} %{NUMBER:[http][response][body][bytes]} %{NUMBER:[http][request][body][bytes]} %{NUMBER:[event][duration]}",

        # IIS HTTP Log Format (without W3SVC)
        "%{TIMESTAMP_ISO8601:[event][start]} %{IP:[server][ip]} %{WORD:[http][request][method]} %{DATA:[url][path]} %{NOTSPACE:[url][query]} %{NOTSPACE:[server][port]} %{NOTSPACE:[user][name]} %{IP:[source][address]} %{DATA:[user_agent][original]} %{NUMBER:[http][response][status_code]} %{NUMBER:[http][response][substatus]} %{NUMBER:[http][response][win32_status]} %{NUMBER:[http][response][body][bytes]} %{NUMBER:[http][request][body][bytes]} %{NUMBER:[event][duration]}",

        # W3C Extended Log File Format
        "%{TIMESTAMP_ISO8601:[event][start]} %{WORD:[server][site]} %{IP:[server][ip]} %{WORD:[http][request][method]} %{URIPATH:[url][path]} %{NOTSPACE:[url][query]} %{NUMBER:[server][port]} %{NOTSPACE:[user][name]} %{IP:[source][address]} %{DATA:[user_agent][original]} %{NUMBER:[http][response][status_code]} %{NUMBER:[iis][sub_status]} %{NUMBER:[iis][win32_status]} %{NUMBER:[http][response][body][bytes]} %{NUMBER:[event][duration]}",

        # W3C/IIS URI path is missing (represented by a dash)
        "%{TIMESTAMP_ISO8601:[event]s[start]} %{WORD:[server][site]} %{IP:[server][ip]} %{WORD:[http][request][method]} (?:%{URIPATH:[url][path]}|-) %{NUMBER:[server][port]} %{NOTSPACE:[user][name]} %{IP:[source][address]} %{DATA:[user_agent][original]} %{NUMBER:[http][response][status_code]} %{NUMBER:[iis][sub_status]} %{NUMBER:[iis][win32_status]} %{NUMBER:[http][response][body][bytes]} %{NUMBER:[event][duration]}",

        # IIS HTTP Log Format (minimal fields)
        "%{TIMESTAMP_ISO8601:[event][start]} %{IP:[server][ip]} %{WORD:[http][request][method]} %{DATA:[url][path]} %{NOTSPACE:[url][query]} %{NOTSPACE:[server][port]} %{NOTSPACE:[user][name]} %{IP:[source][address]} %{DATA:[user_agent][original]} %{NUMBER:[http][response][status_code]} %{NUMBER:[http][response][substatus]} %{NUMBER:[http][response][win32_status]}",

        # IIS FTP Log Format
        "%{TIMESTAMP_ISO8601:[event][start]} %{IP:[source][address]} %{NOTSPACE:[user][name]} %{NOTSPACE:[server][site]} %{IP:[server][ip]} %{NUMBER:[server][port]} %{WORD:[ftp][command]} %{DATA:[url][path]} %{NUMBER:[http][response][status_code]} %{NUMBER:[http][response][win32_status]} %{NUMBER:[http][response][body][bytes]} %{NUMBER:[http][request][body][bytes]} %{NUMBER:[event][duration]}",

        # ATM FTP Log Format
        "%{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR} %{NUMBER:[process][pid]} %{IP:[source][address]} %{NUMBER:[http][response][body][bytes]} %{PATH:[url][path]} %{WORD:[event][action]} %{WORD:[event][type]} %{WORD:[event][direction]} %{WORD:[event][category]} %{NUMBER:[user][id]} %{WORD:[service][type]} %{NUMBER:[event][duration]} %{WORD:[file][name]} %{WORD:[file][extension]}",
        
        # Handle ATM logs where the IP is already translated to a host
        "%{HOSTNAME:[source][address]} - - \[%{HTTPDATE:[event][start]}\] \"%{WORD:[http][request][method]} %{DATA:[url][original]} HTTP/%{NUMBER:[http][version]}\" %{NUMBER:[http][response][status_code]} %{NUMBER:[http][response][body][bytes]}",
        
        # Handle PPI and ATM logs where username info is wonky
        "%{IP:[source][address]} %{NOTSPACE:[user][ident]} %{NOTSPACE:[user][name]} \[%{HTTPDATE:[event][start]}\] \"%{WORD:[http][request][method]} %{URIPATH:[url][original]}(?: HTTP\/%{NUMBER:[http][version]})?\" %{NUMBER:[http][response][status_code]} %{NUMBER:[http][response][body][bytes]} \"%{DATA:[http][request][referrer]}\" \"%{DATA:[user_agent][original]}\"",

        # Apache-style log with IP first
        "%{IP:[source][address]} - - \[%{HTTPDATE:[event][start]}\] \"%{WORD:[http][request][method]} %{DATA:[url][path]} HTTP/%{NUMBER:[http][version]}\" %{NUMBER:[http][response][status_code]} %{NUMBER:[http][response][body][bytes]} \"%{DATA:[http][request][referrer]}\" \"%{DATA:[user_agent][original]}\"",

        # Apache-style log invalid username
        "%{IP:[source][address]} - %{DATA:[user][name]} \[%{HTTPDATE:[event][start]}\] \"%{WORD:[http][request][method]} %{URIPATHPARAM:[http][request][body][content]} HTTP/%{NUMBER:[http][version]}\" %{INT:[http][response][status_code]} %{INT:[http][response][body][bytes]} \"%{DATA:[http][request][referrer]}\" \"%{DATA:[user_agent][original]}\""
      ]
    }
    id => "grok_filter_initial_parse"
    tag_on_failure => "_grok_filter_initial_parse_failure"
  }

  # Copy timestamp to [event][start] for Apache logs
  if [timestamp] and !([event][start]) {
    mutate {
      copy => { "timestamp" => "[event][start]" }
    }
  }

  # Parse all timestamps to @timestamp
  if [event][start] {
    date {
      match => [ "[event][start]", "ISO8601", "yyyy-MM-dd HH:mm:ss", "EEE MMM dd HH:mm:ss yyyy", "dd/MMM/yyyy:HH:mm:ss Z", "dd/MMM/yyyy:HH:mm:ss" ]
      target => "@timestamp"
      timezone => "UTC"
      tag_on_failure => "_datetimeparsefailure"
    }
  } else if [event][action] {
    date {
      match => [ "message", "EEE MMM dd HH:mm:ss yyyy" ]
      target => "@timestamp"
      timezone => "UTC"
      tag_on_failure => "_datetimeparsefailure"
    }
  }

  # Handle datetime parsing failures
  if "_datetimeparsefailure" in [tags] {
    mutate {
      add_field => {
        "[error][message]" => "Failed to parse datetime from %{[event][start]}"
        "[error][type]" => "datetime_parse_error"
        "[error][details][timestamp]" => "%{[event][start]}"
        "[error][details][message]" => "%{message}"
        "[error][details][pattern]" => "dd/MMM/yyyy:HH:mm:ss Z"
      }
    }
  }

  # Handle missing source address
  if ![source][address] {
    mutate {
      add_field => {
        "[error][message]" => "Missing source address in log message"
        "[error][type]" => "missing_source_address"
      }
      add_tag => [ "_missing_source_address" ]
    }
  }

  # Handle IIS-specific fields
  if [http][response][substatus] {
    mutate {
      add_field => {
        "[http][response][status_code]" => "%{[http][response][status_code]}.%{[http][response][substatus]}"
      }
      remove_field => ["[http][response][substatus]"]
    }
  }

  if [http][response][win32_status] {
    mutate {
      add_field => {
        "[error][code]" => "%{[http][response][win32_status]}"
      }
      remove_field => ["[http][response][win32_status]"]
    }
  }

  # Handle FTP-specific fields
  if [ftp][command] {
    if [ftp][command] in ["RETR", "BOTZETR"] {
      mutate {
        add_field => {
          "[event][action]" => "%{[ftp][command]}"
          "[event][category]" => ["file", "network"]
          "[event][type]" => ["access", "info"]
          "[event][outcome]" => "%{[http][response][status_code] < 400 ? 'success' : 'failure'}"
        }
        remove_field => ["[ftp][command]"]
      }
    } else {
      drop {}
    }
  }

  # Map FTP status codes to ECS outcome
  if [http][response][status_code] {
    mutate {
      add_field => {
        "[event][outcome]" => "%{[http][response][status_code] < 400 ? 'success' : 'failure'}"
      }
    }
  }

  # Array to String Conversion
  mutate {
    replace => {
      "[source][address]" => "%{[source][address].is_a?(Array) ? [source][address].first : [source][address]}"
      "[url][path]" => "%{[url][path].is_a?(Array) ? [url][path].first : [url][path]}"
      "[url][domain]" => "%{[url][domain].is_a?(Array) ? [url][domain].first : [url][domain]}"
    }
  }

  # Query Parameter Encoding
  if [url][queryparams] {
    mutate {
      replace => {
        "[url][queryparams]" => "%{URI.encode([url][queryparams].to_s)}"
      }
    }
  }

  # Enhanced Event Outcome and Error Handling
  if [http][response][status_code] and [http][response][status_code] != "" {
    mutate {
      convert => { "[http][response][status_code]" => "integer" }
      tag_on_failure => ["_invalid_status_code"]
    }
    if "_invalid_status_code" not in [tags] {
      if [http][response][status_code] < 400 {
        mutate {
          add_field => {
            "[event][outcome]" => "success"
          }
          id => "set_success_outcome"
        }
      } else {
        mutate {
          add_field => {
            "[event][outcome]" => "failure"
            "[error][type]" => "http_error"
            "[error][message]" => "HTTP %{[http][response][status_code]}"
          }
          id => "set_failure_outcome"
        }
      }
    } else {
      mutate {
        remove_tag => ["_invalid_status_code"]
        add_field => {
          "[event][outcome]" => "unknown"
          "[error][message]" => "Invalid HTTP status code: %{[http][response][status_code]}"
          "[error][type]" => "invalid_status_code"
        }
      }
    }
  }

  # Tag Processing
  mutate {
    replace => {
      "tags" => "%{tags.gsub(/%{[^}]+}/, '').split(',').uniq.join(',')}"
    }
  }

  # URL Component Validation
  if [url][path] == "-" or [url][path] == "%{[url][original]}" {
    mutate {
      remove_field => ["[url][path]"]
      add_tag => ["_missing_url_path"]
    }
  }

  # Enhanced User Agent Parsing
  if [user_agent][original] {
    if [user_agent][original] == "-" {
      mutate {
        replace => { "[user_agent][original]" => "Unknown" }
        add_tag => ["_empty_user_agent"]
      }
    }
    useragent {
      source => "[user_agent][original]"
      target => "[user_agent]"
      remove_field => ["[user_agent][original]"]
      add_field => {
        "[user_agent][device][type]" => "%{[user_agent][device][name]}"
      }
    }
  }

  # Domain Deduplication
  mutate {
    replace => {
      "[url][domain]" => "%{[url][domain].is_a?(Array) ? [url][domain].select { |d| d != [source][address] }.first : [url][domain]}"
    }
  }

  # HTTP Method Validation
  mutate {
    replace => {
      "[http][request][method]" => "%{[http][request][method].upcase}"
    }
  }
  if [http][request][method] and [http][request][method] != "" {
    if [http][request][method] !~ "^(GET|POST|PUT|DELETE|HEAD|OPTIONS|PATCH)$" {
      mutate {
        add_tag => ["_invalid_http_method"]
        add_field => {
          "[error][type]" => "invalid_http_method"
          "[error][message]" => "Invalid HTTP method: %{[http][request][method]}"
        }
      }
    }
  }

  # Clean up fields
  mutate {
    remove_field => [ "timestamp", "date", "time" ]
    id => "cleanup_fields"
  }

  # Extract URL components
  if [url][original] {
    urldecode {
      field => "[url][original]"
      id => "decode_url"
    }
    
    grok {
      ecs_compatibility => "v8"
      match => {
        "[url][original]" => [
          "%{URIPROTO:[url][scheme]}://(?:%{USER:[url][username]}:(?<[url][password]>[^@]*)@)?(?:%{IPORHOST:[url][address]}(?::%{POSINT:[url][port]}))?(?:%{URIPATH:[url][path]}(?:%{URIPARAM:[url][query]}))?",
          "%{IPORHOST:[url][address]}(?::%{POSINT:[url][port]})(?:%{URIPATH:[url][path]}(?:%{URIPARAM:[url][query]}))?",
          "%{URIPATH:[url][path]}(?:%{URIPARAM:[url][query]})"
        ]
      }
      tag_on_failure => "_url_parse_failure"
    }

    if "_url_parse_failure" not in [tags] {
      # parse the address to distinguish domain or ip
      grok {
        match => {
          "[url][address]" => "(%{IP:[source][address]}|%{HOSTNAME:[url][domain]})"
        }
        tag_on_failure => "_grokparsefailure_ipvsdomain"
      }
      # Requires a custom plugin here, see https://www.elastic.co/guide/en/logstash/current/plugins-filters-tld.html
      tld {
        source => "[url][domain]"
        target => "[url][tld]"
      }
      mutate {
        rename => {
          "[url][tld][domain]" => "[url][registered_domain]"
          "[url][tld][tld]" => "[url][top_level_domain]"
          "[url][tld][sld]" => "[url][second_level_domain]"
          "[url][tld][trd]" => "[url][sub_domain]"
        }
        remove_field => [ "[url][tld]" ]
      }
      # parse the query to extract fragment
      grok {
        match => {
          "[url][query]" => "^\?(?<[url][query]>[A-Za-z0-9$.+!*'|(){},~@%&/=:;_?\-\[\]<>]*)(?:#(?:%{WORD:[url][fragment]}))?"
        }
        overwrite => [ "[url][query]" ]
        tag_on_failure => "_grokparsefailure_urlquery"
      }

      if [url][query] {
        kv {
          source => "[url][query]"
          field_split => "&"
          value_split => "="
          target => "[url][queryparams]"
        }
        urldecode {
          field => "[url][query]"
        }
        urldecode {
          field => "[url][queryparams]"
        }
      }
    } else {
      mutate {
        add_field => { "[url][path]" => "%{[url][original]}" }
      }
    }
  }

  # Use uap_core regex patterns to detect bots/spiders
  useragent {
    ecs_compatibility => "v8"
    source => "[user_agent][original]"
    target => "[user_agent]"
    regexes => "${LOGSTASH_CONF_HOME}/regexes.yaml"
    id => "useragent_filter_parse_apache_combined"
  }

  # Determine the geographic location from which the request came.
  if ![tags] and [source][address] {
    geoip {
      ecs_compatibility => "v8"
      source => "[source][address]"
      target => "[source][geo]"
    }

    # Reverse lookup any raw IP addresses to get the domain from which the
    # request originated.
    mutate {
      add_field => { "[source][domain]" => "%{[source][address]}" }
    }

    if [source][address] =~ /^\d{1,3}(\.\d{1,3}){3}$/ {
      dns {
        action => "replace"
        reverse => [ "[source][domain]" ]
        nameserver => [ "10.1.0.2", "8.8.8.8" ] # AWS DNS resolver, Google DNS
        add_tag => [ "_dns_reverse_lookup" ]
        hit_cache_size => 10000
        failed_cache_size => 1000
        failed_cache_ttl => 60
        max_retries => 5
      }
    } else {
      dns {
        action => "replace"
        resolve => [ "[source][address]" ]
        nameserver => [ "10.1.0.2", "8.8.8.8" ] # AWS DNS resolver, Google DNS
        add_tag => [ "_dns_resolve_lookup" ]
        hit_cache_size => 10000
        failed_cache_size => 1000
        failed_cache_ttl => 60
        max_retries => 5
      }
    }
  }

  # Use the raw event message as a UUID to avoid duplication in elasticsearch
  fingerprint {
    ecs_compatibility => "v8"
    source => "message"
    target => "[event][hash]"
    method => "MURMUR3"
  }

  # Convert sequence field to integer
  mutate {
    convert => { "[event][sequence]" => "integer" }
    id => "convert_sequence_to_integer"
  }

  # Ensure consistent HTTP response body bytes handling
  if [http][response][body][bytes] {
    mutate {
      convert => { "[http][response][body][bytes]" => "integer" }
      id => "convert_response_bytes_to_integer"
    }
  }

  # Normalize timestamps
  if [event][start] {
    date {
      match => ["[event][start]", "yyyy-MM-dd HH:mm:ss"]
      target => "@timestamp"
      timezone => "UTC"
    }
  }

  # Map IIS status codes to ECS outcome
  if [http][response][status_code] {
    mutate {
      add_field => {
        "[event][outcome]" => "%{[http][response][status_code] < 400 ? 'success' : 'failure'}"
      }
    }
  }

  # Map FTP commands to event actions
  if [event][action] {
    mutate {
      add_field => {
        "[event][outcome]" => "%{[http][response][status_code] < 400 ? 'success' : 'failure'}"
      }
    }
  }
}
output {
    if "bad_log" in [tags] or "_grok_parse_failure" in [tags] or "_dateparsefailure" in [tags] or "_url_parse_failure" in [tags] or "_invalid_http_method" in [tags] or "_template_variable" in [tags] or "_missing_url_original" in [tags] {
        file {
            path => "${HOME}/logstash/logs/bad_logs_%{+YYYY-MM}.txt"
            codec => line { 
                format => "[%{+YYYY-MM-dd HH:mm:ss}] [%{tags}] File: %{[file][path]} | Message: %{message} | Error: %{[error][message]}"
            }
        }
    } else {
        opensearch {
            ecs_compatibility => "v8"
            index => "en-web-analytics-%{+YYYY-MM}"
            hosts => "https://p5qmxrldysl1gy759hqf.us-west-2.aoss.amazonaws.com:443"
            auth_type => {
                type => 'aws_iam'
                aws_access_key_id => ''
                aws_secret_access_key => ''
                region => 'us-west-2'
                service_name => 'aoss'
            }
            legacy_template => false
            default_server_major_version => 2
            document_id => "%{[event][hash]}"
            manage_template => false
        }
    }
}